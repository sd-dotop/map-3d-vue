define(["./AxisAlignedBoundingBox-7ff48b89","./Transforms-7a61bdac","./Matrix2-590828b3","./defaultValue-69ee94f4","./TerrainEncoding-98773200","./ComponentDatatype-e160d612","./OrientedBoundingBox-a9f82aab","./RuntimeError-0e565491","./WebMercatorProjection-fe996809","./createTaskProcessorWorker","./Check-3bce9c53","./_commonjsHelpers-3aae1032-15991586","./combine-0259f56f","./AttributeCompression-5a90fdf9","./WebGLConstants-f63312fc","./EllipsoidTangentPlane-95768776","./IntersectionTests-935e2a11","./Plane-40d30c90"],(function(t,e,n,i,o,a,r,s,c,u,h,l,d,g,m,p,f,I){"use strict";const E=Uint16Array.BYTES_PER_ELEMENT,T=Int32Array.BYTES_PER_ELEMENT,C=Uint32Array.BYTES_PER_ELEMENT,M=Float32Array.BYTES_PER_ELEMENT,x=Float64Array.BYTES_PER_ELEMENT;function N(t,e,n){n=i.defaultValue(n,a.CesiumMath);const o=t.length;for(let i=0;i<o;++i)if(n.equalsEpsilon(t[i],e,a.CesiumMath.EPSILON12))return i;return-1}const b=new n.Cartographic,S=new n.Cartesian3,w=new n.Cartesian3,B=new n.Cartesian3,P=new n.Matrix4;function A(t,e,o,r,s,c,u,h,l,d,g){const m=h.length;for(let p=0;p<m;++p){const f=h[p],I=f.cartographic,E=f.index,T=t.length,C=I.longitude;let M=I.latitude;M=a.CesiumMath.clamp(M,-a.CesiumMath.PI_OVER_TWO,a.CesiumMath.PI_OVER_TWO);const x=I.height-u.skirtHeight;u.hMin=Math.min(u.hMin,x),n.Cartographic.fromRadians(C,M,x,b),d&&(b.longitude+=l),d?p===m-1?b.latitude+=g:0===p&&(b.latitude-=g):b.latitude+=l;const N=u.ellipsoid.cartographicToCartesian(b);t.push(N),e.push(x),o.push(n.Cartesian2.clone(o[E])),r.length>0&&r.push(r[E]),s.length>0&&s.push(s[E]),n.Matrix4.multiplyByPoint(u.toENU,N,S);const w=u.minimum,B=u.maximum;n.Cartesian3.minimumByComponent(S,w,w),n.Cartesian3.maximumByComponent(S,B,B);const P=u.lastBorderPoint;if(i.defined(P)){const t=P.index;c.push(t,T-1,T,T,E,t)}u.lastBorderPoint=f}}return u((function(u,h){u.ellipsoid=n.Ellipsoid.clone(u.ellipsoid),u.rectangle=n.Rectangle.clone(u.rectangle);const l=function(u,h,l,d,g,m,p,f,I,y,R){let _,W,v,F,O,V;i.defined(d)?(_=d.west,W=d.south,v=d.east,F=d.north,O=d.width,V=d.height):(_=a.CesiumMath.toRadians(g.west),W=a.CesiumMath.toRadians(g.south),v=a.CesiumMath.toRadians(g.east),F=a.CesiumMath.toRadians(g.north),O=a.CesiumMath.toRadians(d.width),V=a.CesiumMath.toRadians(d.height));const Y=[W,F],k=[_,v],H=e.Transforms.eastNorthUpToFixedFrame(h,l),U=n.Matrix4.inverseTransformation(H,P);let L,j;I&&(L=c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(W),j=1/(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(F)-L));const D=1!==m,G=new DataView(u);let z=Number.POSITIVE_INFINITY,q=Number.NEGATIVE_INFINITY;const J=w;J.x=Number.POSITIVE_INFINITY,J.y=Number.POSITIVE_INFINITY,J.z=Number.POSITIVE_INFINITY;const K=B;K.x=Number.NEGATIVE_INFINITY,K.y=Number.NEGATIVE_INFINITY,K.z=Number.NEGATIVE_INFINITY;let Q,X,Z=0,$=0,tt=0;for(X=0;X<4;++X){let t=Z;Q=G.getUint32(t,!0),t+=C;const e=a.CesiumMath.toRadians(180*G.getFloat64(t,!0));t+=x,-1===N(k,e)&&k.push(e);const n=a.CesiumMath.toRadians(180*G.getFloat64(t,!0));t+=x,-1===N(Y,n)&&Y.push(n),t+=2*x;let i=G.getInt32(t,!0);t+=T,$+=i,i=G.getInt32(t,!0),tt+=3*i,Z+=Q+C}const et=[],nt=[],it=new Array($),ot=new Array($),at=new Array($),rt=I?new Array($):[],st=D?new Array($):[],ct=new Array(tt),ut=[],ht=[],lt=[],dt=[];let gt=0,mt=0;for(Z=0,X=0;X<4;++X){Q=G.getUint32(Z,!0),Z+=C;const t=Z,e=a.CesiumMath.toRadians(180*G.getFloat64(Z,!0));Z+=x;const i=a.CesiumMath.toRadians(180*G.getFloat64(Z,!0));Z+=x;const o=a.CesiumMath.toRadians(180*G.getFloat64(Z,!0)),r=.5*o;Z+=x;const u=a.CesiumMath.toRadians(180*G.getFloat64(Z,!0)),h=.5*u;Z+=x;const d=G.getInt32(Z,!0);Z+=T;const g=G.getInt32(Z,!0);Z+=T,Z+=T;const m=new Array(d);for(let t=0;t<d;++t){const s=e+G.getUint8(Z++)*o;b.longitude=s;const d=i+G.getUint8(Z++)*u;b.latitude=d;let g=G.getFloat32(Z,!0);if(Z+=M,0!==g&&g<R&&(g*=-Math.pow(2,y)),g*=6371010,b.height=g,-1!==N(k,s)||-1!==N(Y,d)){const e=N(et,b,n.Cartographic);if(-1!==e){m[t]=nt[e];continue}et.push(n.Cartographic.clone(b)),nt.push(gt)}m[t]=gt,Math.abs(s-_)<r?ut.push({index:gt,cartographic:n.Cartographic.clone(b)}):Math.abs(s-v)<r?lt.push({index:gt,cartographic:n.Cartographic.clone(b)}):Math.abs(d-W)<h?ht.push({index:gt,cartographic:n.Cartographic.clone(b)}):Math.abs(d-F)<h&&dt.push({index:gt,cartographic:n.Cartographic.clone(b)}),z=Math.min(g,z),q=Math.max(g,q),at[gt]=g;const p=l.cartographicToCartesian(b);if(it[gt]=p,I&&(rt[gt]=(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(d)-L)*j),D){const t=l.geodeticSurfaceNormal(p);st[gt]=t}n.Matrix4.multiplyByPoint(U,p,S),n.Cartesian3.minimumByComponent(S,J,J),n.Cartesian3.maximumByComponent(S,K,K);let f=(s-_)/(v-_);f=a.CesiumMath.clamp(f,0,1);let E=(d-W)/(F-W);E=a.CesiumMath.clamp(E,0,1),ot[gt]=new n.Cartesian2(f,E),++gt}const p=3*g;for(let t=0;t<p;++t,++mt)ct[mt]=m[G.getUint16(Z,!0)],Z+=E;if(Q!==Z-t)throw new s.RuntimeError("Invalid terrain tile.")}it.length=gt,ot.length=gt,at.length=gt,I&&(rt.length=gt);D&&(st.length=gt);const pt=gt,ft=mt,It={hMin:z,lastBorderPoint:void 0,skirtHeight:f,toENU:U,ellipsoid:l,minimum:J,maximum:K};ut.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),ht.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),lt.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),dt.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));const Et=1e-5;if(A(it,at,ot,rt,st,ct,It,ut,-Et*O,!0,-Et*V),A(it,at,ot,rt,st,ct,It,ht,-Et*V,!1),A(it,at,ot,rt,st,ct,It,lt,Et*O,!0,Et*V),A(it,at,ot,rt,st,ct,It,dt,Et*V,!1),ut.length>0&&dt.length>0){const t=ut[0].index,e=pt,n=dt[dt.length-1].index,i=it.length-1;ct.push(n,i,e,e,t,n)}$=it.length;const Tt=e.BoundingSphere.fromPoints(it);let Ct;i.defined(d)&&(Ct=r.OrientedBoundingBox.fromRectangle(d,z,q,l));const Mt=new o.EllipsoidalOccluder(l).computeHorizonCullingPointPossiblyUnderEllipsoid(h,it,z),xt=new t.AxisAlignedBoundingBox(J,K,h),Nt=new o.TerrainEncoding(h,xt,It.hMin,q,H,!1,I,D,m,p),bt=new Float32Array($*Nt.stride);let St=0;for(let t=0;t<$;++t)St=Nt.encode(bt,St,it[t],ot[t],at[t],void 0,rt[t],st[t]);const wt=ut.map((function(t){return t.index})).reverse(),Bt=ht.map((function(t){return t.index})).reverse(),Pt=lt.map((function(t){return t.index})).reverse(),At=dt.map((function(t){return t.index})).reverse();return Bt.unshift(Pt[Pt.length-1]),Bt.push(wt[0]),At.unshift(wt[wt.length-1]),At.push(Pt[0]),{vertices:bt,indices:new Uint16Array(ct),maximumHeight:q,minimumHeight:z,encoding:Nt,boundingSphere3D:Tt,orientedBoundingBox:Ct,occludeePointInScaledSpace:Mt,vertexCountWithoutSkirts:pt,indexCountWithoutSkirts:ft,westIndicesSouthToNorth:wt,southIndicesEastToWest:Bt,eastIndicesNorthToSouth:Pt,northIndicesWestToEast:At}}(u.buffer,u.relativeToCenter,u.ellipsoid,u.rectangle,u.nativeRectangle,u.exaggeration,u.exaggerationRelativeHeight,u.skirtHeight,u.includeWebMercatorT,u.negativeAltitudeExponentBias,u.negativeElevationThreshold),d=l.vertices;h.push(d.buffer);const g=l.indices;return h.push(g.buffer),{vertices:d.buffer,indices:g.buffer,numberOfAttributes:l.encoding.stride,minimumHeight:l.minimumHeight,maximumHeight:l.maximumHeight,boundingSphere3D:l.boundingSphere3D,orientedBoundingBox:l.orientedBoundingBox,occludeePointInScaledSpace:l.occludeePointInScaledSpace,encoding:l.encoding,vertexCountWithoutSkirts:l.vertexCountWithoutSkirts,indexCountWithoutSkirts:l.indexCountWithoutSkirts,westIndicesSouthToNorth:l.westIndicesSouthToNorth,southIndicesEastToWest:l.southIndicesEastToWest,eastIndicesNorthToSouth:l.eastIndicesNorthToSouth,northIndicesWestToEast:l.northIndicesWestToEast}}))}));
